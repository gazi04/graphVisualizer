<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Graph Visualization</title>
    <script src="node_modules/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/graphology@1.0.0/dist/graphology.umd.js"></script>
    <script src="PriorityQueue.js"></script>
    <script src="graphVisualizer.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="grid">
        <div class="navbar">
            <button onclick="setGraphType('simple')">Simple Graph</button>
            <button onclick="setGraphType('pseudo')">Pseudograph</button>
            <button onclick="setGraphType('directed')">Directed Graph</button>
            <button onclick="setGraphType('weighted')">Weighted Graph</button>
            <div id="graphTypeIndicator">Current Graph Type: Simple Graph</div>
        </div>

        <div class="right">
            <div id="mynetwork"></div>
        </div>
        
        <div class="left">
            <div class="terminal">
                <div id="output"></div>
                <input type="text" id="commandInput" class="input" autofocus>
            </div>
        </div>
    </div>

    <!-- To use a Graph object -->
    <script src="graphology/graphology.min.js"></script>
    <script>
// function findEulerianPath(graph) {
//     if (!isGraphConnected(graph)) {
//         throw new Error('Graph is not connected. Eulerian path does not exist.');
//     }

//     const copyGraph = graphology.Graph.from(graph);

//     let path = [];

//     let currentNode = findStartingNode(copyGraph);

//     while (copyGraph.size > 0) {
//         const neighbor = findNextNeighbor(currentNode, copyGraph);

//         if (neighbor === null) break;

//         // let edgeToBeDeleted;
//         // graph.forEachEdge(
//         // (edge, attributes, source, target, sourceAttributes, targetAttributes) => {
//         //     if((source == currentNode && target == neighbor) || (source == neighbor && target == currentNode))
//         //        edgeToBeDeleted = edge; 
//         // });

//         copyGraph.dropEdge(currentNode, neighbor);

//         path.push(currentNode);

//         currentNode = neighbor;
//     }

//     path.push(currentNode);

//     return path;
// }

// function isGraphConnected(graph) {
//     const startingNode = graph.nodes()[0];

//     const visitedNodes = new Set();
//     dfs(graph, startingNode, visitedNodes);

//     return visitedNodes.size === graph.order;
// }

// function dfs(graph, node, visitedNodes) {
//     visitedNodes.add(node);
//     for (const neighbor of graph.neighbors(node)) {
//         if (!visitedNodes.has(neighbor)) {
//             dfs(graph, neighbor, visitedNodes);
//         }
//     }
// }

// function findStartingNode(graph) {
//     for (const node of graph.nodes()) {
//         if (graph.degree(node) % 2 === 1) {
//             return node;
//         }
//     }
//     return graph.nodes()[0];
// }

// function findNextNeighbor(node, graph) {
//     const neighbors = graph.neighbors(node);
    
//     for (const neighbor of neighbors) {
//         if (graph.hasEdge(node, neighbor)) {
//             return neighbor;
//         }
//     }
//     return null;
// }

// Function to check if the graph has an Eulerian path
function hasEulerianPath(graph) {
    // Count nodes with odd degrees
    let oddDegreeCount = 0;
    graph.forEachNode(node => {
        if (graph.degree(node) % 2 !== 0) {
            oddDegreeCount++;
        }
    });
    // Eulerian path exists if there are exactly 0 or 2 nodes with odd degree
    return oddDegreeCount === 0 || oddDegreeCount === 2;
}

function findEulerianPath(graph) {
    if (!hasEulerianPath(graph)) {
        throw new Error('Graph does not have an Eulerian path.');
    }

    const edges = [];
    const PATH = [];
    const startNode = graph.nodes()[0];
    let currentNode = startNode;

    graph.forEachEdge((edge, attr, source, target) => {
        edges.push({ startNode: source, endNode: target });
    });

    while (edges.length > 0) {
        PATH.push(currentNode);
        const nextEdgeIndex = edges.findIndex(edge => edge.startNode === currentNode);
        if (nextEdgeIndex !== -1) {
            const nextEdge = edges.splice(nextEdgeIndex, 1)[0];
            currentNode = nextEdge.endNode;
        } else {
            const i = edges.findIndex(edge => edge.endNode === currentNode);
            currentNode = edges.splice(i, 1)[0].startNode;
        }
    }

    PATH.push(currentNode);
    return PATH;
}

// Example usage
const graph = new graphology.Graph();
graph.addNode('1');
graph.addNode('2');
graph.addNode('3');
graph.addNode('4');
graph.addNode('5');
graph.addEdge('1', '2');
graph.addEdge('1', '3');
graph.addEdge('3', '2');
graph.addEdge('2', '4');
graph.addEdge('5', '2');
graph.addEdge('4', '5');

const eulerianPath = findEulerianPath(graph);
console.log('Eulerian Path:', eulerianPath.join(' -> '));


    </script>
    <script>
        // const visualizer = new GraphVisualizer('mynetwork');
        // // By default the graph is a simple graph
        // const graph = new graphology.Graph({allowSelfLoops: false});
        // const pseudoGraph = new graphology.Graph({multi: true, allowSelfLoops: true});
        // const diagraph = new graphology.DirectedGraph({allowSelfLoops: false});
        // const weightedGraph = new graphology.Graph({type: "undirected", weighted: true, allowSelfLoops: false});
        // let currentGraphType = "simple"
        
        // fetch('nodes.json')
        // .then(response => response.json())
        // .then(nodeData => {
        //     nodeData.forEach(node => {
        //         // A node in a simple graph has two main properties the id (for unique values, for distinciton) 
        //         // and the label as a node attribute (for the end user, the name of the node that's displayed)
        //         graph.addNode(node.id);
        //         graph.setAttribute(node.id, node.label);

        //         pseudoGraph.addNode(node.id);
        //         pseudoGraph.setAttribute(node.id, node.label);

        //         diagraph.addNode(node.id);
        //         diagraph.setAttribute(node.id, node.label);

        //         weightedGraph.addNode(node.id);
        //         weightedGraph.setAttribute(node.id, node.label);

        //         visualizer.addNode(node.id, node.label);
        //     });

        //     fetch("edges.json")
        //     .then(response => response.json())
        //     .then(edgeData => {
        //         edgeData.forEach(edge => {
        //             if(!(edge.from === edge.to)){
        //                 graph.addEdge(edge.from, edge.to);
        //                 // By default the graph doesn't allow self loops, that's the reason why the line below
        //                 // is inside the body of this if statement 
        //                 visualizer.addEdge(edge.from.toString(), edge.to.toString());
        //             }
        //             pseudoGraph.addEdge(edge.from, edge.to);
        //             diagraph.addDirectedEdge(edge.from, edge.to);
        //             weightedGraph.addEdge(edge.from, edge.to, {value: edge.weight});

        //             visualizer.createNetwork();
        //         });
        //     })
        //     .catch(error => console.error("Error fetching edges:", error));
        // })
        // .catch(error => console.error('Error fetching nodes:', error));

        // function setGraphType(type){
        //     if(type == "simple"){
        //         currentGraphType = "simple";
        //         visualizer.IsDirected = false;
        //         visualizer.IsWeighted = false;
        //         visualizer.HasLoops = false;

        //         visualizer.clearNodes();
        //         graph.forEachNode((node) => {visualizer.addNode(node, graph.getAttribute(node));});

        //         visualizer.clearEdges();
        //         graph.forEachEdge((edge, attr, source, target) =>{visualizer.addEdge(source, target);});
        //         visualizer.updateGraph();
        //     }
        //     else if(type == "pseudo"){
        //         currentGraphType = "pseudo";
        //         visualizer.IsDirected = false;
        //         visualizer.IsWeighted = false;
        //         visualizer.HasLoops = true;

        //         visualizer.clearNodes();
        //         pseudoGraph.forEachNode((node) => {visualizer.addNode(node, pseudoGraph.getAttribute(node));});

        //         visualizer.clearEdges();
        //         pseudoGraph.forEachEdge((edge, attr, source, target) => {visualizer.addEdge(source, target);});
        //         visualizer.updateGraph();
        //     }
        //     else if(type == "directed"){
        //         currentGraphType = "directed";
        //         visualizer.IsDirected = true;
        //         visualizer.IsWeighted = false;
        //         visualizer.HasLoops = false;
               
        //         visualizer.clearNodes();
        //         diagraph.forEachNode((node) => {visualizer.addNode(node, diagraph.getAttribute(node));}); 

        //         visualizer.clearEdges();
        //         diagraph.forEachEdge((edge, attr, source, target) =>{visualizer.addEdge(source, target);});
        //         visualizer.updateGraph();
        //     }
        //     else if(type == "weighted"){
        //         currentGraphType = "weighted";
        //         visualizer.IsDirected = false;
        //         visualizer.IsWeighted = true;
        //         visualizer.HasLoops = false;

        //         visualizer.clearNodes();
        //         weightedGraph.forEachNode((node) => {visualizer.addNode(node, weightedGraph.getAttribute(node));});

        //         visualizer.clearEdges();
        //         weightedGraph.forEachEdge((edge, attr, source, target) =>{visualizer.addEdgeWithWeight(source, target, attr.value);});
        //         visualizer.updateGraph();
        //     }

        //     document.getElementById("graphTypeIndicator").innerHTML = `Current Graph Type: 
        //     ${currentGraphType.charAt(0).toUpperCase()+currentGraphType.slice(1)} Graph`;
        //     visualizer.Network.redraw();
        // }
    </script>
    <script src="graph.js"></script>
</body>
</html>
